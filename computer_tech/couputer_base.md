[回目录页](..)

![avatar](/image/computer_tech_structs.png)


# **1.操作系统的四个特性**

* 并发： 同一段时间内多个程序执行(注意区别并行和并发，前者是同一时刻的多个事件，后者是同一时间段内的多个事件)

* 共享： 系统中的资源可以被内存中多个并发执行的进线程共同使用

* 虚拟： 通过时分复用（如分时系统）以及空分复用（如虚拟内存）技术实现把一个物理实体虚拟为多个

* 异步： 系统中的进程是以走走停停的方式执行的，且以一种不可预知的速度推进

# **2.操作系统的主要功能**

* 进程管理： 处理机分配都是以进程为单位，所以处理机管理也被看做是进程管理。包括进程控制，进程同步，进程通信和进程调度

* 内存管理： 内存分配，内存保护，地址映射，内存扩充

* 设备管理： 管理所有外围设备，包括完成用户的IO请求；为用户进程分配IO设备；提高IO设备利用率；提高IO速度；方便IO的使用

* 文件管理： 管理用户文件和系统文件，方便使用同时保证安全性。包括：磁盘存储空间管理，目录管理，文件读写管理以及文件共享和保护

* 提供用户接口： 程序接口（如API）和用户接口（如GUI）

# **3. 进程的状态的转换**

![avatar](/image/computer_process_status.png)

* 运行状态：进程在处理机中运行。单机环境下，每个时刻最多只能有一个进程在运行状态。

* 就绪状态: 进程以已处于准备运行的状态，即进程已经获得了处理机之外的所有资源，等待处理机调度运行，一旦得到处理机即可运行

* 阻塞状态：进程在等待某一事件而暂停运行，如等待某资源为可用或等待输入输出，即使梳理机空闲，该进程也会不能运行。

**就绪状态->运行状态：** 处于就绪状态的进程获得处理机资源（处理机给分派了时间片）

**运行状态->就绪状态：** 处于运行状态的进程时间片用完了，或者有更高优先级的进行就绪让高优先级的执行（可剥夺的操作系统）

**运行状态->阻塞状态：** 当进程请求某一个资源的使用或者等待某一个时间的发生，则变成阻塞状态。

**阻塞状态->就绪状态：** 当进行请求的资源或则等待的事件完成，则从阻塞状态切换回就绪状态。


# **4. 进程与线程的区别**

* 根本区别： 进程是**操作系统**分配资源的基本单位，而线程是**处理器任务调度**和执行的基本单位，一个进程可以拥有多个线程

* 资源开销：每个进程都有独立的代码和数据空间，进程切换会有比较大的开销；线程可以共享进程代码和数据空间，且每个线程都有自己的独立运行栈和程序计数器，线程之间切换开销小。

* 包含关系：线程是进程的一部分

* 内存分配：同一个进程中的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的

* 影响关系：一个进程崩溃后并不会影响其他进程，但一个线程崩溃后同进程的其他线程都会死掉。

* 执行过程： 独立进程都有程序运行入口；线程不能独立执行，必须依赖在应用程序即进程。

# **5. 进程通信**

### 5.1 共享存储

   在通信进程之间存在一块可直接访问的共享空间，通过这块共享空间进行读/写操作实现进程之间的信息交换，在对共享空间进行读写操作时，需要使用同步互斥工具（如p操作和v操作）
  
### 5.2 消息传递

   操作系统提供的信息传递方法进行进程通信，以格式化的消息为单位（Message）,包含两种方式
   
* 1. 直接通信方式：发送进程直接把消息发送给接受进程，并把它挂在接受进程的消息缓冲队列上，接受进程从消息队列中取得消息

* 2. 间接通信方式：发送进行将消息发送给到某个中间实体中，接受进程从中间实体中取得消息。   
   
### 5.3 管道通信 

   管道通信是消息传递的一种特殊方式；所谓管道，是指用于连接一个读进程和一个写进程以实现他们之间通信的一个共享文件，又名pipe文件。
   
   为协调读写双方的通讯，管道机制提供了以下三方面的协调能力： 互斥，同步和确定对方存在
   
   只能单一方向传输数据，不能双向数据传输
   
**管道特点：**

1. 只能用于具有共同祖先的进程通信，例如父子进程

2. 进程退出后管道释放，所以管道生命周期跟随进程

3. 由内核来对管道进行同步和互斥

4. 管道是半双工，数据只能朝一个方向流动，需要双方通信时，需要建立起两个管道

   
### 5.4 信号量通讯

  是一个特殊的**计数器**，来完成多进程环境下的进程行的同步控制。
  
  互斥访问的P操作就是上锁，V操作就是解锁
  
  信号量是一个值，当信号量大于1时，则表示资源闲置。小于0，则表示自愿不可用，并至少有一个进程在等待资源。等于0表示资源忙，但没有进程等待这个保护的资源。

### 5.5 Socket通讯   
  
   就是使用IP地址和端口的网络通信
   
   
# **6. 进程同步**
  
   多进行虽然提高了系统资源利用率和吞吐量，但是由于进行的异步性可能导致资源混乱。
   
   进行同步的解决方案：管程，信号量

# **7.用户态和核心态**

   当程序运行在3级特权级上时，就可以称之为运行在用户态。反之，当程序运行在级特权级上时，就可以称之为运行在内核态。
   
   虽然用户态下和内核态下工作的程序有很多差别，但最重要的差别就在于特权级的不同，即权力的不同
   
   
# **8.死锁**
  
### 8.1 死锁原因：
  
* 竞争资源：请求同一有限资源的进程数多于可用资源数
* 进程推进顺序非法：进程执行中，请求和释放资源顺序不合理，如资源等待链 

### 8.2 死锁产生的必要条件

* 互斥条件:进程对所分配的资源进行排他性的使用
* 请求和保持条件：进程被阻塞的时候并不释放锁申请到的资源
* 不可剥夺条件：进程对于已经申请到的资源在使用完成之前不可以被剥夺
* 环路等待条件：发生死锁的时候存在的一个 进程-资源 环形等待链

### 8.3 死锁的处理

预防死锁：破坏产生死锁的4个必要条件中的一个或者多个；实现起来比较简单，但是如果限制过于严格会降低系统资源利用率以及吞吐量

避免死锁：在资源的动态分配中，防止系统进入不安全状态(可能产生死锁的状态)-如银行家算法

检测死锁：允许系统运行过程中产生死锁，在死锁发生之后，采用一定的算法进行检测，并确定与死锁相关的资源和进程，采取相关方法清除检测到的死锁。实现难度大

解除死锁：与死锁检测配合，将系统从死锁中解脱出来（撤销进程或者剥夺资源）。对检测到的和死锁相关的进程以及资源，通过撤销或者挂起的方式，释放一些资源并将其分配给处于阻塞状态的进程，使其转变为就绪态。实现难度大

# **9.进程调度算法**

* **先来先服务调度算法FCFS** 既可以作为作业调度算法也可以作为进程调度算法；按作业或者进程到达的先后顺序依次调度；因此对于长作业比较有利；

* **短作业优先调度算法SJF：** 作业调度算法，算法从就绪队列中选择估计时间最短的作业进行处理，直到得出结果或者无法继续执行；缺点：不利于长作业；未考虑作业的重要性；运行时间是预估的，并不靠谱 ；

* **高响应比算法HRN：** 响应比=(等待时间+要求服务时间)/要求服务时间；

* **时间片轮转调度RR：** 按到达的先后对进程放入队列中，然后给队首进程分配CPU时间片，时间片用完之后计时器发出中断，暂停当前进程并将其放到队列尾部，循环 ;

* **多级反馈队列调度算法：** 目前公认较好的调度算法；设置多个就绪队列并为每个队列设置不同的优先级，第一个队列优先级最高，其余依次递减。优先级越高的队列分配的时间片越短，进程到达之后按FCFS放入第一个队列，如果调度执行后没有完成，那么放到第二个队列尾部等待调度，如果第二次调度仍然没有完成，放入第三队列尾部……只有当前一个队列为空的时候才会去调度下一个队列的进程。

# **10 内存管理**

(见页面)[https://github.com/LRH1993/android_interview/blob/master/operating-system/memory-management.md]