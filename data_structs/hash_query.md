[回目录页](..)

# Hash数据结构

### 1.1 简述

   Hash表是以键-值对存储数据的结构，只要输入待key ,即可拿到其value.
   
   **使用哈希查找有两个步骤:**
   
   * 使用哈希函数将被查找的键转换为数组的索引。在理想的情况下，不同的键会被转换为不同的索引值，但是在有些情况下我们需要处理多个键被哈希到同一个索引值的情况。所以哈希查找的第二个步骤就是处理冲突
   
   * 处理哈希碰撞冲突。有很多处理哈希碰撞冲突的方法，本文后面会介绍**拉链法**和**线性探测法**。
   
   
### 3.2 hash函数

   希函数将键映射成索引，这种映射函数就是哈希函数。
   
   **正整数的hash索引：** 使用除留余数法；即对于大小为素数M的数组，对于任意正整数k，计算k除以M的余数。M一般取素数
   
   **字符串的hash索引：** 
   
```
  public int hashCode() {
        int h = hash;
        final int len = length();
        if (h == 0 && len > 0) {
            for (int i = 0; i < len; i++) {
                h = 31 * h + charAt(i);
            }
            hash = h;
        }
        return h;
    }
```

### 3.3 避免Hash冲突

* 拉链法
  
  通过哈希函数，我们可以将键转换为数组的索引(0-M-1)，但是对于两个或者多个键具有相同索引值的情况，
   
  将大小为M 的数组的每一个元素指向一个条链表，链表中的每一个节点都存储散列值为该索引的键值对，这就是拉链法。

![avatar](/image/hash_link_struct.png)

  方法的基本思想就是选择足够大的M，使得所有的链表都尽可能的短小，以保证查找的效率。
  
  对采用拉链法的哈希实现的查找分为两步，首先是根据散列值找到对应的链表，然后沿着链表顺序找到相应的键
  
* 线下探测法
  开放寻址法中最简单的是线性探测法：当碰撞发生时即一个键的散列值被另外一个键占用时，直接检查散列表中的下一个位置即将索引值加1，这样的线性探测会出现三种结果：

1. 命中，该位置的键和被查找的键相同
2. 未命中，键为空
3. 继续查找，该位置的键和被查找的键不同。

  线性探查（Linear Probing）方式虽然简单，但是有一些问题，它会导致同类哈希的聚集。在存入的时候存在冲突，在查找的时候冲突依然存在。  