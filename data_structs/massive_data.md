[回目录页](..)

# 海量数据

# 1. 简介
  
   主要是指的海量数据的存储，处理和操作。 主要从时间和空间的角度考虑
   
   针对时间即速度，可以采用巧妙的算法搭配恰当的数据结构，例如Bloom Filter/Hash/bit-map/堆/trie树
   
   针对空间，则是大而化小，分而治之。
   
# 2. 算法/数据结构基础

### 2.1 Bloom Filter
  
   Bloom Filter（BF）是一种空间效率很高的随机数据结构，
   
   **它利用位数组很简洁地表示一个集合，并能判断一个元素是否属于这个集合。它是一个判断元素是否存在集合的快速的概率算法。**
   
   Bloom Filter有可能会出现错误判断，但不会漏掉判断。也就是Bloom Filter判断元素不再集合，那肯定不在。如果判断元素存在集合中，有一定的概率判断错误。因此，Bloom Filter不适合那些“零错误”的应用场合。
   
   而在能容忍低错误率的应用场合下，Bloom Filter比其他常见的算法（如hash，折半查找）极大节省了空间。
   
   适用范围
   可以用来实现数据字典，进行数据的判重，或者集合求交集
   
[Bloom Filter海量数据详解](https://blog.csdn.net/v_july_v/article/details/6685894)

### 2.2 Hash算法

   通过hash算法把任意长度的数据输入，转化成固定长度的输出
   
   这是属于压缩映射， 即输出长度会远小于输入长度。
   
   不同的输入，进行hash算法后，可能得到相同的输出
   
(Hash表算详解)[https://blog.csdn.net/v_july_v/article/details/6256463]   
   
### 2.4  位图法

 位图法就是bitmap的缩写。所谓bitmap，就是用每一位来存放某种状态，适用于大规模数据，但数据状态又不是很多的情况。通常是用来判断某个数据存不存在的
 
 假设我们要对0-7内的5个元素(4,7,2,5,3)排序（这里假设这些元素没有重复）。那么我们就可以采用Bit-map的方法来达到排序的目的。要表示8个数，我们就只需要8个Bit（1Bytes） 
 
![avatar](/image/bitmap_data.jpeg)

 ### 2.5 堆
 
 堆是一种特殊的二叉树，具备以下两种性质
 
 1）每个节点的值都大于（或者都小于，称为最小堆）其子节点的值
 
 2）树是完全平衡的，并且最后一层的树叶都在最左边这样就定义了一个最大堆。
 
 如下图用一个数组来表示堆：
 
 ![avatar](/image/stack_masive.jpeg)
 
 ### 2.6 字典树，trie树

![avatar](/image/trie_tree_sample.png)

从上面的图中，我们或多或少的可以发现一些好玩的特性。


* 第一：根节点不包含字符，除根节点外的每一个子节点都包含一个字符。

* 第二：从根节点到某一节点，路径上经过的字符连接起来，就是该节点对应的字符串。

* 第三：每个单词的公共前缀作为一个字符节点保存。


**使用范围**

   既然学Trie树，我们肯定要知道这玩意是用来干嘛的。

 
 * 第一：词频统计。

            可能有人要说了，词频统计简单啊，一个hash或者一个堆就可以打完收工，但问题来了，如果内存有限呢？还能这么

             玩吗？所以这里我们就可以用trie树来压缩下空间，因为公共前缀都是用一个节点保存的。

 * 第二: 前缀匹配

            就拿上面的图来说吧，如果我想获取所有以"a"开头的字符串，从图中可以很明显的看到是：and,as,at，如果不用trie树，

            你该怎么做呢？很显然朴素的做法时间复杂度为O(N2) ，那么用Trie树就不一样了，它可以做到h，h为你检索单词的长度，

            可以说这是秒杀的效果。
 
### 2.7 外排序

大数据的排序，去重

**基本原理及要点：**

外部排序的两个独立阶段：

* 1）首先按内存大小，将外存上含n个记录的文件分成若干长度L的子文件或段。依次读入内存并利用有效的内部排序对他们进行排序，并将排序后得到的有序字文件重新写入外存，通常称这些子文件为归并段。

* 2）对这些归并段进行逐趟归并，使归并段逐渐由小到大，直至得到整个有序文件为之。

外排序的优化方法：**置换选择**  **败者树原理**，**最优归并树**    