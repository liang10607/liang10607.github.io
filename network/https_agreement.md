[回目录页](..)

# Https

  HTTPS其实是有两部分组成：HTTP + SSL / TLS，也就是在HTTP上又加了一层处理加密信息的模块。

  ![https_ssl_tls_flow](/image/https_ssl_tls_flow.png)

# Https数据加密流程详解

### 1. 客户端发起Https请求

    浏览器或者android客户端输入https网址，然后连接到server的443端口。

### 2. 服务端的配置

    服务器要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面(startssl就是个不错的选择，有1年的免费服务)

### 3. 传送证书

   这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。

###  4. 客户端解析证书

    这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随即值。然后用证书对该随机值进行加密。就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。
###  5. 传送加密信息

    这部分传送的是用证书加密后的随机值

### 6. 服务段加密信息

    服务端用私钥解密后，得到了客户端传过来的随机值(对称加密信息)，然后把内容通过该值进行对称加密

###  7. 传输加密后的信息

    这部分信息是服务段用私钥加密后的信息，可以在客户端被还原

###  8. 客户端解密信息

    客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容。整个过程第三方即使监听到了数据，也束手无策。    

# Https的证书自定义


# Https证书的漏洞和证书攻击

[https](https://blog.csdn.net/xiaoming100001/article/details/81109617)


[https证书的中间人攻击](https://blog.csdn.net/zxh2075/article/details/80741032)

### http的SSL四次握手

![https_ssl_tls_flow](/image/ssl_four_hand.png)

[浅析HTTPS中间人攻击与证书校验](https://blog.csdn.net/zxh2075/article/details/80741032)

  https握手过程的证书校验环节就是为了识别证书的有效性唯一性等等，所以严格意义上来说https下不存在中间人攻击.

  存在中间人攻击的前提条件是没有严格的对证书进行校验，或者人为的信任伪造证书，下面一起看下几种常见的https“中间人攻击”场景
  
**避免中间人攻击**

通过上文第一和第二部分的说明，相信大家已经对https有个大概的了解了，那么问题来了，怎样才能防止这些“中间人攻击”呢?

app证书校验已经是一个老生常谈的问题了，但是市场上还是有很多的app未做好证书校验，有些只做了部分校验，

   例如检查证书域名是否匹配证书是否过期，更多数的是根本就不做校验，于是就造成了中间人攻击。做证书校验需要做完全，只做一部分都会导致中间人攻击，

   对于安全要求并不是特别高的app可使用如下校验方式：查看证书是否过期 服务器证书上的域名是否和服务器的实际域名相匹配 校验证书链

   可参考http://drops.wooyun.org/tips/3296，此类校验方式虽然在导入CA公钥证书到客户端之后会造成中间人攻击，但是攻击门槛已相对较高，所以对于安全要求不是特别高的app可采用此方法进行防御。
   
   对于安全有较高要求一些app(例如金融)上述方法或许还未达到要求，那么此时可以使用如下更安全的校验方式，将服务端证书打包放到app里，再建立https链接时使用本地证书和网络下发证书进行一致性校验，可参考安卓官方提供的https连接demo：https://developer.android.com/training/articles/security-ssl.html  

* **1. 客户端发出请求（Client Hello）**

> （1） 支持的协议版本，比如TLS 1.0版。
  （2） 一个客户端生成的**随机数**，稍后用于生成"对话密钥"。
  （3） 支持的加密方法，比如RSA公钥加密。
  （4） 支持的压缩方法。

* **2. 服务器响应（Server Hello）**

> （1） 确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。
  （2） 确认使用的加密方法，比如RSA公钥加密，返回加密公钥
  （3） **服务器证书**

* **3. 客户端回应**

> a) 验证证书的合法性（颁发证书的机构是否合法，证书中包含的网站地址是否与正在访问的地址一致等），如果证书受信任，则浏览器栏里面会显示一个小锁头，否则会给出证书不受信的提示。
  b) 如果证书受信任，或者是用户接受了不受信的证书，浏览器会生成一串随机数的密码，并用证书中提供的公钥加密。
  c) 使用约定好的HASH计算握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给网站


* **4. 服务端处理**

> a) 使用自己的私钥将信息解密取出密码，使用密码解密浏览器发来的握手消息，并验证HASH是否与浏览器发来的一致。
  b) 使用密码加密一段握手消息，发送给浏览器
