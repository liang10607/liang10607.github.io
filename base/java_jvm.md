[回目录页](..)

# Java虚拟机

## 重点学习资料
[Intro.pdf](/Files/Java_JVM_II.pdf)

## Java内存区域和内存溢出
### java运行时的数据区

![avatar](/image/java_jvm_data_area.png)
> 方法区（公有）： 用户存储已被虚拟机加载的类信息，常量，静态常量，即时编译器编译后的代码等数据。异常状态 OutOfMemoryError

> 其中包含常量池：用户存放编译器生成的各种字面量和符号引用。

> 堆（公有）： 是JVM所管理的内存中最大的一块。唯一目的就是存放实例对象，几乎所有的对象实例都在这里分配。Java堆是垃圾收集器管理的主要区域，因此很多时候也被称为“GC堆”。异常状态 OutOfMemoryError

> 虚拟机栈（线程私有）： 描述的是java方法执行的内存模型：每个方法在执行时都会创建一个栈帧，用户存储局部变量表，操作数栈，动态连接，方法出口等信息。每一个方法从调用直至完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。 对这个区域定义了两种异常状态 OutOfMemoryError StackOverflowError

> 本地方法栈（线程私有）: 与虚拟机栈所发挥的作用相似。它们之间的区别不过是虚拟机栈为虚拟机执行java方法，而本地方法栈为虚拟机使用到的Native方法服务。

> 程序计数器（线程私有）： 一块较小的内存，当前线程所执行的字节码的行号指示器。字节码解释器工作时，就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。

关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，Java内存模型中定义了8种操作来完成，并且每种操作都是原子的、不可再分的。

八种操作：

| 类型 |	说明|
| --- | --- |
| lock | 	作用于主内存的变量，把一个变量标识为一条线程独占的状态|
| unlock | 	作用于主内存的变量，把一个处于锁定状态的变量释放出来。|
| read | 	把一个变量的值从主内存传输到工作内存中，以便随后的load使用。|
| load | 	把read操作从主内存中得到的变量值放入到工作内存的变量副本中。|
| use | 	把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。|
| assign | 	把一个从执行引擎中接收到的值赋值给工作内存中的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。|
| store	|  把工作内存中的一个变量的值传递到主内存，以便随后的write使用。|
| write	|  把store操作从工作内存中得到的变量值放入到主内存的变量中。|

1. 程序计数器
   程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前**线程**所执行的字节码的行号指示器。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。
2. 虚拟机栈，本地方法栈:方法运行的内存模型，是线程私有的
3. 数据堆：存储对象和常量数据
4. 分析数据是否为垃圾的方法：引用计数算法，可达性算法
5. 清除垃圾的算法包括：标记清除法，复制法，标记整理法，分代收集算法

### 分带收集算法
大部分的对象都很短命，都在很短的时间内都被回收了（IBM 专业研究表明，一般来说，98% 的对象都是朝生夕死的，经过一次 Minor GC 后就会被回收），所以分代收集算法根据对象存活周期的不同将堆分成新生代和老生代
1. 新生代：新生代又分为 Eden 区， from Survivor 区（简称S0），to Survivor 区(简称 S1),三者的比例为 8: 1 : 1。
   * 第一次GC时先标记Eden区的存活对象，然后使用复制算法把存活对象复制到S0区并清空Eden。第二次GC时会把Eden和S0存活的对象复制到S1,并清空eden和S0.
   * 每次GC时，新生代中的存活对象都会对其年龄加1
   * 当新生代对象的年龄达到阈值，则会呗移动到老年代中
   * 大对象会直接分配到老年代中
   * 在 S0（或S1） 区相同年龄的对象大小之和大于 S0（或S1）空间一半以上时，则年龄大于等于该年龄的对象也会晋升到老年代。
2. 老年代的空间担保：虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，如果大于，那么Minor GC 可以确保是安全的,如果不大于，那么虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于则进行 Minor GC，否则可能进行一次 Full GC。
3. Stop The World：如果老年代满了，会触发 Full GC, Full GC 会同时回收新生代和老年代（即对整个堆进行GC），它会导致 Stop The World（简称 STW）,造成挺大的性能开销。什么是 STW ？所谓的 STW, 即在 GC（minor GC 或 Full GC）期间，只有垃圾回收器线程在工作，其他工作线程则被挂起。

### Java堆和栈的区别
1. 栈存储的时线程的局部变量和方法调用，堆是存储全局的Java对象
2. 栈是线程独享，堆是全局共享
3. 栈满了后报StackOverFlowErro,堆满了是会报OutOfMemeryErro
4. 栈内存是远远低于堆内存的，例如栈内递归没及时跳出，会报StackOverFlowErro

### 强引用，软引用，弱引用，虚引用
1. 强引用，系统宁愿发生OutOfMemery也不会回收
2. 软引用，如果内存空间充足，则不会呗回收，若是不充足时则不会被回收
> 垃圾收集线程会在虚拟机抛出OutOfMemoryError之前回收软引用对象，而且虚拟机会尽可能优先回收长时间闲置不用的软引用对象。SoftReference  ReferenceQueue
3. 弱引用：一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。

## Javad对象创建,内存布局，访问定位
### 对象创建
new指令->常量池找类的符号引用->检查该类是否被加载，解析和初始化，没有的话，则执行加载动作->为对象分配内存空间

### 对象的内存布局
对象内存分为三个部分：对象头，实例数据，对齐补充

#### 对象头
  * 第一部分：对象自身运行数据，如Hash码，GC分代年龄，锁状态标记，线程持有的锁，偏向线程ID,偏向锁等；分别占用32bit或者64bit,官方称其为Mark Word
  * 第二部分：类型指针，虚拟机通过该指针判断对象是属于哪个类的实例。若是java数组，则对象头还有个字段用于标示数组长度

#### 实例数据
是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容

#### 对齐填充
对齐填充不是必然存在的。HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，对象头是符合要求的， 但实例数据根据实际存储情况进行补齐

### 对象的访问定位
ava程序需要通过栈上了reference数据来操作堆上的具体对象。

目前主流的访问方式有使用句柄和直接指针两种。

* 句柄访问
![avatar](/image/refenrence_visit_1.png)

* 直接访问
![avatar](/image/refenrence_2.png)

## Java类加载机制
### 定义
    把描述类的数据从class文件加载到内存中，并对数据进行校验，转化解析和初始化，最终形成可以被虚拟机直接使用的Java类型
    
    类的加载过程都在程序运行期间完成的，这回带来性能的一些消耗， 但也使得java语言具备更多的动态和灵活性特征


