[回目录页](..)

## 1. 二维数据中的查找
### **题目**
在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
   
### **思路**
   
   首先选取数组中右上角的数字。如果该数字等于要查找的数字，查找过程结束。
   
   如果该数字大于要查找的数字，剔除这个数字所在的列：如果该数字小于要查找的数字，剔除这个数字所在的行。
   
   也就是说如果要查找的数字不在数组的右上角，则每－次都在数组的查找范围中剔除行或者一列，这样每一步都可以缩小查找的范围，直到找到要查找的数字，或者查找范围为空。
   
## 2. 替换空格
###    **题目**
   请实现一个函数，把字符串中的每个空格替换成"%20"，例如“We are happy.”，则输出“We%20are%20happy.”。
  
###    **思路**
   
   先判断字符串中空格的数量。根据数量判断该字符串有没有足够的空间替换成"%20"。
       
   如果有足够空间，计算出需要的空间。根据最终需要的总空间，维护一个指针在最后。从后到前，遇到非空的就把该值挪到指针指向的位置，然后指针向前一位，遇到“ ”，则指针前移，依次替换为“02%”。   

## 3. 从尾到头打印链表
###    **题目**
   输入个链表的头结点，从尾到头反过来打印出每个结点的值。
        
###    **思路**
   将链表从头压如栈中，再出栈。 栈是后进先出的结构

# 4. ***重建二叉树***
###    **题目**
   输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如：前序遍历序列｛ 1, 2, 4, 7, 3, 5, 6, 8｝和中序遍历序列｛4, 7, 2, 1, 5, 3, 8，6}，重建二叉树并输出它的头结点。     
###    **思路**
   当前对二叉树还是不够熟悉，得加强
   
## 5. 用两个栈实现队列
###    **题目**
     用两个栈实现一个队列。队列的声明如下，请实现它的两个函数appendTail 和deleteHead。  

###    **思路**
栈1用于存储元素，栈2用于弹出元素，负负得正。

```
public class Test {  
    public static class MList<T> {  
        // 插入栈，只用于插入的数据  
        private Stack<T> stack1 = new Stack<>();  
        // 弹出栈，只用于弹出数据  
        private Stack<T> stack2 = new Stack<>();  
  
        public MList() {  
        }  
          
        // 添加操作，成在队列尾部插入结点  
        public void appendTail(T t) {  
            stack1.add(t);  
        }  
  
        // 删除操作，在队列头部删除结点  
        public T deleteHead() {  
  
            // 先判断弹出栈是否为空，如果为空就将插入栈的所有数据弹出栈，  
            // 并且将弹出的数据压入弹出栈中  
            if (stack2.isEmpty()) {  
                while (!stack1.isEmpty()) {  
                    stack2.add(stack1.pop());  
                }  
            }  
  
            // 如果弹出栈中还没有数据就抛出异常  
            if (stack2.isEmpty()) {  
                throw new RuntimeException("No more element.");  
            }  
  
            // 返回弹出栈的栈顶元素，对应的就是队首元素。  
            return stack2.pop();  
        }  
    }  
```

## 6. 旋转数组的最小数字
###    **题目**
    数组中有两段已经排序过的子数组，通过数组的翻转，实现整个数据的快速排序。

###    **思路**

**Step1.**和二分查找法一样，我们用两个指针分别指向数组的第一个元素和最后一个元素。

**Step2.**接着我们可以找到数组中间的元素：

如果该中间元素位于前面的递增子数组，那么它应该大于或者等于第一个指针指向的元素。此时数组中最小的元素应该位于该中间元素的后面。我们可以把第一个指针指向该中间元素，这样可以缩小寻找的范围。如果中间元素位于后面的递增子数组，那么它应该小于或者等于第二个指针指向的元素。此时该数组中最小的元素应该位于该中间元素的前面。

**Step3.**接下来我们再用更新之后的两个指针，重复做新一轮的查找。

## 7. 斐波那契数列实现
###    **题目**
写一个函数，输入n，求斐波那契数列的第n项值。

斐波那契数列的定义如下：






        
###    **思路**
    
## 8. 
###    **题目**
        
###    **思路**

## 9. 
###    **题目**
        
###    **思路**
   
## 10. 
###    **题目**
        
###    **思路**

## 11. 
###    **题目**
        
###    **思路**
   
## 12. 
###    **题目**
        
###    **思路**